This is my revision note for Git, I 
update it regularly when I learn 
something new. I've also included the 
basic git concepts so that a beginner
can also learn from this.
Also the indentation of the file is 
kept in such a way that the content 
can be best viewed on Github mobile app
so that you can read it on the go.
Also Pull Requests and Fork section is
not present in this note.

=====1)GIT WORKING UNDER THE HOOD=====
Git stores all the information in the
.git directory using objects.
There are four types of git objects

1.Blob: To store files
2.Tree: Information about directory
3.Commit: Helps to have different 
snapshot/versions of the project.
4.Annotated Tag: Persistent text 
pointer to specific commit.

Ex. Let's suppose you have two files in
working directory file1.txt and 
file2.txt
After initializing git, adding both 
files to staging area and finally 
commit them as 'initial commit'
Internally git will create one commit
object containing description of 
commit, author name and author email 
and associate a SHA1 hash with that.
Also note that Commit is just a wrapper 
around tree object.
Therefore it will point to a tree 
object which will eventually contain 
links to two blobs-file1.txt and
file2.txt
Special Note: git reuses blob for files
having same content and does not create
new blob to save disk space.

As this repo is meant to be regarding
git commands so there will be no more
detail regarding internal working of 
git. Also it's hard to tell everything
without using of diagrams.

==Get Info of Objects using SHA1 Hash==
Get the content
    git cat-file -p SHA1Hash

Get the size
    git cat-file -s SHA1Hash

Get the type
    git cat-file -t SHA1Hash

============2)INITIAL SETUP============
Set Git Author name and Email
git config --global user.name 'Name'
git config --global user.email 'Email'

Verify using,
    git config --list

=========3)BASIC GIT COMMANDS=========
Add file to staging area,
    git add <filename>

If you want to add all the files to the
staging area, use
    git add .

View the content of staging area,
    git ls-files

If you want to view along with SHA1
hashes use,
    git ls-files -s

To commit the files from staging area
and write changes to git repository
    git commit -m 'Your Message'

To find all the files of git repository
    find .git/objects -type f

To get history of changes(Commits)
    git log

To checkout commit or branch
    git checkout <commit id/branch>
You'll get into detached head state if 
you try to checkout to specific commit

To clone a repo
    git clone <url>

To find the modification
    git diff

=========4)GIT FILES LIFECYCLE=========
Untracked Modified Staged Unmodified

Untracked->Staged: git add[for new 
files]
Staged->Unmodified: git commit
After commit, if you change file in 
the working directory,
It will change state Unmodified->
Modified Again you've to use git add to
add it to staging area and do further 
commit.
Files can also be untracked, means can 
be moved from Unmodified->Untracked

=====Entire lifecycle in a nutshell====
---------------------------------------
WorkingDirectory|StagingArea|GitRepo
---------------------------------------
Untracked       |Staged     |
Modified        |           |
Unmodified      |Unmodified |Unmodified
---------------------------------------

When you add new file in working 
directory, it becomes untracked. Means
untracked files are only located in 
working directory.
After you stage that file, it goes into
staging area as well as present in 
working directory.
After commit, git writes everything
about the file in git repository[using
git objects] and change the state back
to unmodified.
Now the file is present in all the 
three  areas i.e. in working directory,
in staging area as well as in git 
repository
After changing the content of the file,
it changes to the modified state in the
working directory, next you have to add 
it to staging area and finally commit 
that.
And after all the steps, the file will
change the state back to unmodified and
will also be present in all the three
areas.This entire process runs in loop.

==============5)GIT BRANCH=============
Default branch is master/main
Pointers for all branches are located 
in .git/refs/heads
Current branch tracks new commits.
Branch pointer moves automatically 
after every new commit
You can't use spaces in branch name.

To list all the branch,
    git branch
To add a branch,
    git branch new-branch
To change branch,
    git checkout <branch-name>
To rename a branch,
    git branch -m <old-name> <new-name>
To delete a branch,
    git branch -d <branch-name>

Note for deletion:
With lowercase -d while deleting, you
can only delete merged branch.
If you want to delete non-merged branch
use uppercase -D

=============What is HEAD?=============
Head is reference to the currently 
checked-out branch or commit.
It is locally significant, means if can
use head locally on your system as your
wish. This is not going to affect the 
remote repo associated with that.
Pointer is located in the 
.git/HEAD file
Default pointer is ref: 
refs/heads/master
You can check where head is pointing by
viewing the content of HEAD in .git
directory and then looking up the 
content of the mentioned path.
e.g. cat refs/heads/master
It should point to the last commit if 
you have not checked out to any other
commit.

If you checkout to some other commit 
using commit SHA1hash Id, then head 
will be detached from the branch as 
branch is pointing to the last commit.
To point head back to the master 
branch,use 'git checkout branch'.

=============Merge Branch=============
To merge commit, first checkout to the
receiving branch. Then use,
git merge <merging-branch-name>
e.g. git checkout main
     git merge new-feature

There are two types of merge that git
uses:
1.Fast Forward Merge: It is possible
when there are no further commits in 
the receiving branch after the commit 
where new branch was created.
For this, git simply shift the 
receiving branch pointer and the head 
pointer to the pointer where new branch
is pointing i.e. at the very last 
commit in the new branch. There will 
not be any commits in this case while
merging.
After this new branch can be deleted.

2.Three Way Merge: This merge happens
when there are further commits in the
receiving branch after the commit where
new branch was created.
Git simply creates a brand new commits
whose parents are two commits: one is 
the last commit from the receiving
branch and other is the last commit of
the new branch.
New branch pointer still points at the
very last commit of the new branch.
After successfully merging, the new
branch can be deleted.
It is also known as recursive way of
merge and git will prompt to enter 
commit message in this case as git has
to create a brand new commit.
After writing the commit message, exit
from the terminal using esc and then 
typing :wq and pressing enter after
that.

============Merge Conflicts============
Merge conflicts don't appear in fast
forward merge.
This is only possible when there are
additional commits in receiving branch
after the commit where new branch was 
created. 
Merge conflicts occur when you edit the
same file in the new branch as well as 
the receiving branch.
If there are conflicts, git will stop
merging and tell you to solve the 
conflicts.
Git stores three different versions of
the conflicted file in the staging area
  0: common file in both the branch
     [ancestor commit file]
  1: file in the receiving branch
  2: file in the new branch
It can be verified by using command,
    git ls-files -s
and after that reading the contents of
the three different files using command
    git cat-file -p <SHA1Hash>
The options available while solving 
conflicts are: keep the change from
receiving branch, keep the change from
new branch or else modify the content
as per your wish.
After that we need to stage the file in
order for git to understand that user
has resolved the conflict.
You can do anything with the file, and
then afterwards git will be able to 
merge the branches.
It's better to use VSCode to solve the
conflicts.

===============6)GITHUB================
Git is distributed version-control
system whereas Github provides
repository hosting service.
'tree' in Github URL doesn't represent
Git tree object. Instead it is just
pointer to specific branch or commit.
e.g. /tree/master
     /tree/new-feature
     /tree/837462afhasf...(SHA1Hash)

==========7)REMOTE REPOSITORY==========
Remote repository is same as local
repository in terms of structure i.e.
we have working directory, staging area
and git repository.
Some FAQs regarding remote repo!!
Q)Do remote repo update itself after
local repo is changed?
Ans) No. You have to manually push the
file from the local repo in order for
the remote repo to update.
Q)Do local repo update itself after
remote repo is changed?
Ans) No. You have to manually pull the
file from the remote repo in order for
the local repo to update.
Q)Who has the right to push to remote
repo?
Ans)Only you and whoever you have 
provided the rights to push. Other than
that no one else can push to your repo.
Q)Who has the right to view the 
contents of my repo?
Ans)If the repo is public, then anyone.
Else only you.

========8)GIT PUSH,FETCH & PULL========
Git push means pushing the changes from
the local repo to the remote repo.
Git fetch gets the updates(branch,
commits,etc.) from the 
remote repo but doesn't update the 
staging area and working directory.
Git pull fetches the updates as well as
files and updates the staging area
as well as working directory. This is
same as doing git fetch first and then
git merge after that.

============What is Origin?============
By default when we clone a repo git
automatically creates a remote with the
name of 'origin'. This is the default
remote for you remote repository.
It can be verified using command
    git remote -v
We can have multiple remote repository
and can actually choose to which remote
repo we want to push or pull the items
from.
If we write only 'git pull' then by
default git will pull files from origin
remote.
If you use command 'git branch' that is
only going to show you local branches.
Also Git will not create corresponding
local branches for all remote branches
except default remote branch.
To show all the branches,
    git branch -a
To show only remote branches,
    git branch -r

===========Tracking Branches===========
Tracking branches are the local branch
connected specifically to the remote
branch.
It might be possible that there are
branches which are present in local
repo but are not present in remote repo
and vice-versa. These are non-tracking
branches.
When you checkout branch in local repo
which is present in remote repo but not
in local repo. Git will automatically
start tracking that branch and connect
it to the remote repo.
To list all the tracking branches,
    git branch -vv
Example for better understanding:
Let's suppose you create a remote repo
online on GitHub and create one new
branch 'new-feature' there. So the 
remote repo will have two branch:
main/master and new-feature
After cloning this repo to your local
drive there will only be one branch 
by default present 'master/main'
tracking corresponding remote branch.
It can be verified using command,
git branch -vv
Now after that if you use the command,
git checkout new-feature then git will
create one additional tracking branch
which will track the remote branch
'new-feature'
So if you type 'git branch -vv' now 
that is going to show two branches 
which tracks corresponding remote 
branch.
To show detailed information regarding
all the remote and local branch, use
    git remote show origin
If you create some branch on remote 
repo you have to use 'git fetch'
command in order to see the new branch
locally.
If you delete some branch remotely,
after that use 'git remote show origin'
and that deleted branch will be marked
as stale.
After that you can use the command
'git remote prune origin' to delete 
and now it'll not be present anymore.
'git branch -vv' will now show that
the tracking branch has been gone.
After that you can delete corresponding
local branch.

================GIT Pull===============
Pull -> Fetch + Merge FETCH_HEAD
Git fetch gets all the latest update
from the remote repo to the local repo
(such as all new commits that were 
created in the remote repo, now will be
available in the local repo).
Also creates the required objects(blob,
commit,tree,tags) for the same in .git 
folder.
After that,Git performs Merge operation
locally. Git will merge remote branch
to the local branch but by using 
FETCH_HEAD present in .git folder,
which will point to last commit in 
remote repo corresponding branch.
Also Git will try to apply fast-forward
merge if possible, else will apply
three way merge.
Git pull only updates the currently
checked out branch, not the other 
present branches.
Before pull, make sure it is tracking
branch and has corresponding remote
branch.
To watch all the background process 
that git does while pull, use the 
verbose flag(-v) like this,
    git pull -v
If we read the contents of the
FETCH_HEAD file present in .git folder
using cat .git/FETCH_HEAD
We can pretty much see everything by
ourselves, that the currently checked
out branch is for merge and other
branches are marked as not for merge.
We can also merge manually using
'git merge FETCH_HEAD'
To delete remote branch from terminal,
    git push origin -d <branch-name>
To check local references,
    ls .git/refs/heads
To check remote references,
    ls .git/refs/remotes/origin
To check local and remote references 
for a specific branch,
    git show-ref <branch-name>
To show all the reference where remote
and local branches are pointing,
    git show-ref
To change author name and email for the
very last commit,
    git commit --amend --author="Reet
    Priye" <reetpriye@gmail.com>

==============9)GIT TAGS===============
Tag is static text pointer to specific
commit.
Staging Vs Production:
  Git is primarily used for software
  development. And in modern days,
  software are developed using CI/CD
  principle.
  CI/CD: Continuous Integration/
         Continuous Development
  According to that there are two 
  environments staging and production.
  For staging mainly branch release is
  used and for production, master is 
  used.
  Staging:
           -primarily for testing
           -usually for internal use
           -merging is performed freq.
           -different branches gets 
            merged into release branch
           -multiple people may have
            merge rights
  Development: 
           -for stable production
           -for customers
           -usually online release 
            branch gets merged
           -hotfixes may go directly
            into production
           -only few people have merge
            rights

Semantic Versioning:
  Major version<-5.1.3->Patch version
                   |
              Minor version

  Minor version should be incremented,
  when there are small changes in the
  project and also it doesn't lead to 
  incompatibility of any package or
  dependencies from previous version.

  Also pre-release versioning is done
  like this 5.1.3-alpha or 5.1.3-beta
  or 5.1.3-1.3 which will be converted
  to 5.1.3 upon final release.
  Also we can use 5.1.3-rc.2[rc stands
  for release candidate], when we are
  pretty close for next release.
  Read more @ https://semver.org

Git Tags are of two types:
  Lightweight tag:
    -stored in the .git/refs/tags
    command: git tag v1.0.0
    -not pushed to remote

  Annotated tag:
    -stored in the .git/refs/tags and
    also in .git/objects
    -stores tag message
    -stores tag author and date
    command: git tag -a v1.0.0 -m 'msg'

Tag name must be unique across repo.
Tag just point to the last commit where
that tag was created.
The content can be read using command,
    cat .git/refs/tags/v1.0.0
Also it can be checked that Lightweight
tags are not present in the objects 
folder using command,
    ls -la .git/objects
An annotated tag contents can be read
using the command,
    git tag -v v1.0.0
It will throw error when used with a
lightweight tag
Also lightweight tags are not pushed
to remote by default.

To push only specific tag use command,
    git push -v <tagName>
To push tags to remote use command,
    git push -v --tags

==============10)REBASING==============